"""
This file contains high-level hardware module for doing gated confocal scans with MadCityLabs piezo stage.
Gating is achieved using ISS functionality of the MCL controller.
"""

import numpy as np
from hardware.mcl.MCL import MCL
from core.module import Base
from interface.empty_interface import EmptyInterface


class MCLScanner(Base, EmptyInterface):

    _activated = False
    _piezo = None
    _n_axes = None   # Number of axes on the piezo
    _x_scan = False
    _scan_coords = None
    _scan_length = 0
    _read_clock_frequency = 1000
    _write_clock_frequency = 200

    def on_activate(self):
        """ Initialize MCL piezo controller at start up
        """
        self._piezo = MCL()
        handle = self._piezo.open()
        if handle != 0:
            self._activated = True
            bitmap = self._piezo.info['axis_bitmap']
            self._n_axes = int(round(np.log2(bitmap + 1)))
        else:
            self.log.error('Could not activate MCL piezo controller!')


    def on_deactivate(self):
        """ Release MCL piezo controller at shut down
        """
        self.reset_hardware()


    def set_up_clock(self, clock_frequency=200, clock_channel=None):
        """ Bind pixel clock of the MCL piezo to x axis.
        @param float clock_frequency: if defined, this sets the frequency of
                                      the clock
        @param string clock_channel: if defined, this is the physical channel
                                     of the clock
        @return int: number of clock signals per pixel or -1 for error

        Note: In MCL, pixel clock is generated by ADC (by reading piezo position)
        and moving of piezo is done by DAC (by writing to piezo controller). Because of weird MCL design,
        DAC and ADC have different frequencies, which means that it is only practical
        to generate pixel clock at 500 and 1000 Hz, and therefore piezo must be moved
        at an integer fraction of that frequency (but not less that 200 Hz - the lowest supported frequency).
        This means that there could be several clock signals per pixel. This value is the return
        of the function in case of success. In case of error, a value of -1 is returned.
        """
        if not self._activated:
            self.log.error('MCL is not activated')
            return -1
        if not clock_frequency in [200, 250, 500, 1000]:
            self.log.error('Unsupported frequency. The only frequencies supported by MCL are 200, 250, 500, and 1000 Hz.')
            return -1

        self._piezo.issReset()
        # bind pixel clock to x axis read
        retval = self._piezo.issBindClockToAxis(axis=5)
        if retval == 0:
            if clock_frequency in [500, 1000]:
                # One of the directly supported ADC frequencies:
                self._read_clock_frequency = clock_frequency
                self._write_clock_frequency = clock_frequency
                return 1
            else:
                # Generate clocks at 1000 Hz
                self._read_clock_frequency = 1000
                self._write_clock_frequency = clock_frequency
                # Number of clock signals per pixel
                return int(1000/clock_frequency)
        else:
            self.log.error('Could not set up ISS functionality of the MCL controller')
            return -1


    def close_clock(self):
        """ Unbind all axis from the pixel clock.
        """
        self._piezo.issReset()
        return 0


    def write_scanner_coords(self, coords, length=1, start=False):
        """ Do one of the following:
        - if start is False, then just save the coords. No actual move.
        - if start is True, then move immediately with singleWrite() or using Waveform

        Since multi-axis waveform functionality is not supported by MCL, check
        whether actual move is along all three axes or just x axis. In the latter case,
        do not load (y,z,a) to waveform, but set a flag and later move with singleWrite()
        on all axes except x.
        TODO:
         - Write the first coordinate twice to cohere with (self._line_length + 1) - investigate this

        @param float[][n] coords: array of n-part tuples defining the coordinate points in meters
                    n depends on how many channels are configured for output and no more than self._n_axes
        @param int length: number of tuples to write
        @param bool start: write immediately (True)
                           or wait for start of task (False)
        @return int: the actual number of samples per channel successfully written to the buffer

        The positions is typically a matrix like
            [[x_values], [y_values], [z_values], [a_values]]
            but x, xy, xyz and xyza are allowed formats.
        """
        if not self._activated:
            self.log.error('MCL is not activated')
            return -1
        if self._piezo.is20bit and length > 6666:
            self.log.error('Too long scan line is requested. Maximum length for this MCL device is 6666 points.')
            return -1
        if not self._piezo.is20bit and length > 10000:
            self.log.error('Too long scan line is requested. Maximum length for this MCL device is 10000 points.')
            return -1

        # Crop array to the number of available axes
        coords = np.array(coords[:self._n_axes, :])

        # Convert coordinates to um
        coords = coords*1.e+6

        # Single move
        if length == 1 and start:
            for xs in range(len(coords)):
                self._piezo.singleWrite(position=coords[xs, 0], axis=xs+1)
            return 1

        # Waveform move
        # Duplicate first coordinate (column) to cohere with (self._line_length + 1) in NI module
        coords = np.c_[coords[:,0], coords]
        # Save coordinates
        self._scan_coords = coords
        # Save scan length
        length += 1
        self._scan_length = length

        # Check if this is x scan (all other coordinates are not changing)
        self._x_scan = True
        for xs in range(len(coords)-1):
            if np.amin(coords[xs+1]) != np.amax(coords[xs+1]):
                self._x_scan = False
                break

        # If start is True, initialize actual piezo move
        if start == True:
            self.scan_line()

        return len(coords[0])


    def scan_line(self):
        """ Initiate waveform move configured with write_scanner_coords()
        """
        if not self._activated:
            self.log.error('MCL is not activated')
            return -1
        # First, move all axes except x
        for xs in range(len(self._scan_coords) - 1):
            # If this is x scan, write yza coordinates with singleWrite()
            if self._x_scan:
                self._piezo.singleWrite(position=self._scan_coords[xs+1, -1], axis=xs+2)
            # Otherwise, write yza coordinates as waveform
            else:
                self._piezo.writeWaveform(
                    waveform=self._scan_coords[xs+1, :],
                    axis=xs+2,
                    delay=1000/self._write_clock_frequency)

        # Finally, write x axis as waveform (pixel clock will be generated by WaveformRead)
        self._piezo.setupWriteWaveform(
            waveform=self._scan_coords[0, :],
            axis=1,
            delay=1000/self._write_clock_frequency)
        # Number of clock signals per pixel (per single piezo move)
        cpp = int(self._read_clock_frequency/self._write_clock_frequency)
        self._piezo.setupReadWaveform(
            length=self._scan_length * cpp,
            axis=1,
            delay=1000/self._read_clock_frequency)
        self._piezo.triggerReadAndWrite(length=self._scan_length * cpp, axis=1)


    def reset_hardware(self):
        """ Release MCL piezo controller, so that other programs can access it.
        """
        if self._piezo is not None:
            self._piezo.close()
            self._piezo = None
            self._activated = False
        return 0

