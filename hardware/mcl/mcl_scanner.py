"""
This file contains high-level hardware module for doing gated confocal scans with MadCityLabs piezo stage.
Gating is achieved using ISS functionality of the MCL controller.
"""

import numpy as np
from hardware.mcl.MCL import MCL
from core.module import Base
from interface.empty_interface import EmptyInterface


class MCLScanner(Base, EmptyInterface):

    _activated = False
    _piezo = None
    # Number of axes on the piezo
    _n_axes = None
    # Defines which axis (0-based index) is the scan axis (usually X) or None for an arbitrary scan
    _scan_axis = None
    _scan_coords = None
    _scan_length = 0
    _read_clock_frequency = 1000
    _write_clock_frequency = 200

    def on_activate(self):
        """ Initialize MCL piezo controller at start up
        """
        self._piezo = MCL()
        handle = self._piezo.open()
        if handle != 0:
            self._activated = True
            bitmap = self._piezo.info['axis_bitmap']
            self._n_axes = int(round(np.log2(bitmap + 1)))
        else:
            self.log.error('Could not activate MCL piezo controller!')


    def on_deactivate(self):
        """ Release MCL piezo controller at shut down
        """
        self.reset_hardware()


    def set_up_clock(self, clock_frequency=200, clock_channel=None):
        """ Bind pixel clock of the MCL piezo to waveform read events.
        @param float clock_frequency: if defined, this sets the frequency of
                                      the clock
        @param string clock_channel: if defined, this is the physical channel
                                     of the clock
        @return int: number of clock signals per pixel or -1 for error

        Note: In MCL, pixel clock is generated by ADC (by reading piezo position),
        while moving of piezo is done by DAC (by writing to piezo controller).
        Because of weird MCL design, DAC and ADC have different frequencies, which means that
        it is only practical to generate pixel clock at 500 or 1000 Hz, and therefore piezo must be moved
        at an integer fraction of that frequency (but not less than 200 Hz - the lowest supported frequency).
        This means that there could be several clock signals per pixel. This value is the return
        of the function in case of success. In case of error, a value of -1 is returned.
        """
        if not self._activated:
            self.log.error('MCL is not activated')
            return -1
        if not clock_frequency in [200, 250, 500, 1000]:
            self.log.error('Unsupported frequency. The only frequencies supported by MCL are 200, 250, 500, and 1000 Hz.')
            return -1

        self._piezo.issReset()
        # bind pixel clock to waveform read
        retval = self._piezo.issBindClockToAxis(axis=5)
        if retval == 0:
            if clock_frequency in [500, 1000]:
                # One of the directly supported ADC frequencies:
                self._read_clock_frequency = clock_frequency
                self._write_clock_frequency = clock_frequency
                return 1
            else:
                # Generate clocks at 1000 Hz
                self._read_clock_frequency = 1000
                self._write_clock_frequency = clock_frequency
                # Number of clock signals per pixel
                return int(1000/clock_frequency)
        else:
            self.log.error('Could not set up ISS functionality of the MCL controller')
            return -1


    def close_clock(self):
        """ Unbind all axis from the pixel clock.
        """
        self._piezo.issReset()
        return 0


    def write_scanner_coords(self, coords, length=1, start=False):
        """ Do one of the following:
        - if start is False, then just save the coords. No actual move.
        - if start is True, then move immediately with singleWrite() or using Waveform

        Since multi-axis waveform functionality is not supported by MCL, check
        whether actual move is along all three axes or just one axis. In the latter case,
        set a flag so that scan_line() would later move with singleWrite() on all axes except one.
        TODO:
         - Write the first coordinate twice to cohere with (self._line_length + 1) - is it needed?

        @param float[][n] coords: array of n-part tuples defining the coordinate points in meters
                    n depends on how many channels are configured for output and no more than self._n_axes
        @param int length: number of tuples to write
        @param bool start: write immediately (True)
                           or wait for start of task (False)
        @return int: the actual number of samples per channel successfully written to the buffer

        The positions is typically a matrix like
            [[x_values], [y_values], [z_values], [a_values]]
            but x, xy, xyz and xyza are allowed formats.
        """
        if not self._activated:
            self.log.error('MCL is not activated')
            return -1
        if self._piezo.is20bit and length > 6666:
            self.log.error('Too long scan line is requested. Maximum length for this MCL device is 6666 points.')
            return -1
        if not self._piezo.is20bit and length > 10000:
            self.log.error('Too long scan line is requested. Maximum length for this MCL device is 10000 points.')
            return -1

        # Crop array to the number of available axes
        coords = np.array(coords[:self._n_axes, :])

        # Convert coordinates to um
        coords = coords*1.e+6

        # Single move
        if length == 1 and start:
            for xs in range(len(coords)):
                self._piezo.singleWrite(position=coords[xs, 0], axis=xs+1)
            return 1

        # Waveform move
        # Duplicate first coordinate (column) to cohere with (self._line_length + 1) in NI module
        coords = np.c_[coords[:,0], coords]
        # Save coordinates
        self._scan_coords = coords
        # Save scan length
        length += 1
        self._scan_length = length

        # Check if this is a single-axis scan (coordinates of other axes are not changing)
        self._scan_axis = None
        for xs in range(len(coords)):
            # Is this coordinate axis changing?
            if np.amin(coords[xs]) != np.amax(coords[xs]):
                if self._scan_axis is None:
                    # This is so far the only changing coordinate axis
                    self._scan_axis = xs
                else:
                    # This is not the only changing coordinate axis
                    self._scan_axis = None
                    break

        # If start is True, initialize actual piezo move
        if start == True:
            self.scan_line()

        return len(coords[0])


    def scan_line(self):
        """ Initiate waveform move configured with write_scanner_coords()
        """
        if not self._activated:
            self.log.error('MCL is not activated')
            return -1

        # If NOT a single-axis scan, move all axes except X
        if self._scan_axis is None:
            clock_axis = 0  # Clock will be generated by X axis, which is the last to be moved
            for xs in range(len(self._scan_coords) - 1):
                self._piezo.writeWaveform(
                    waveform=self._scan_coords[xs+1, :],
                    axis=xs+2,
                    delay=1000/self._write_clock_frequency)
        # For a single-axis scan, move only to the first coordinate of each stationary axes,
        # while the scan axis is only marked, but moved later
        else:
            clock_axis = self._scan_axis
            for xs in range(len(self._scan_coords)):
                if xs != clock_axis:
                    self._piezo.singleWrite(position=self._scan_coords[xs, 0], axis=xs+1)

        # Move single axis and generate a pixel clock (by Waveform Read)
        self._piezo.setupWriteWaveform(
            waveform=self._scan_coords[clock_axis, :],
            axis=clock_axis+1,  # In MCL, axis indexing is 1-based
            delay=1000/self._write_clock_frequency)
        # Number of clock signals per pixel (per single piezo move)
        cpp = int(self._read_clock_frequency/self._write_clock_frequency)
        self._piezo.setupReadWaveform(
            length=self._scan_length * cpp,
            axis=clock_axis+1,  # In MCL, axis indexing is 1-based
            delay=1000/self._read_clock_frequency)
        self._piezo.triggerReadAndWrite(length=self._scan_length * cpp, axis=clock_axis+1)


    def reset_hardware(self):
        """ Release MCL piezo controller, so that other programs can access it.
        """
        if self._piezo is not None:
            # Move to zero position for piezo safety
            for i in range(self._n_axes):
                self._piezo.singleWrite(position=0, axis=i+1)
            self._piezo.close()
            self._piezo = None
            self._activated = False
        return 0

